---

### 🚀 DSA Roadmap: Topic-Wise Progression (Beginner → Pro)

We'll move in increasing order of complexity. Here's your DSA Topics Blueprint:

---

#### 1. **Arrays & Strings**
- Basics, Traversal, Prefix/Suffix, Sliding Window
- Two Pointers, Kadane's Algo, Sorting Variants

#### 2. **Hashing / HashMaps / HashSets**
- Frequency Count, Map-based Logic, Anagrams
- Custom Hashing, Collision Handling (theory)

#### 3. **Recursion & Backtracking**
- Basic recursion, Subset/Permutation generation
- N-Queens, Sudoku Solver, Rat in Maze

#### 4. **Linked List**
- Singly & Doubly Linked List, Reversal, Cycle Detection
- Merge Sort on LL, K-group Reverse, Clone LL

#### 5. **Stacks & Queues**
- Infix/Postfix, Monotonic Stack, Next Greater Element
- Sliding Window Max, Min Stack, LRU Cache

#### 6. **Trees**
- Traversals (In/Post/Pre, Level Order)
- Binary Search Tree (BST)
- Diameter, LCA, Views, Morris Traversal
- Segment Trees, Binary Indexed Trees (Advanced)

#### 7. **Heaps / Priority Queue**
- Min/Max Heaps, Heap Sort
- Top K elements, Median Finder
- Custom Comparators

#### 8. **Tries**
- Insert/Search, Word Dictionary
- Longest Prefix, AutoComplete
- XOR-based Problems

#### 9. **Greedy Algorithms**
- Activity Selection, Job Scheduling, Huffman Encoding
- Fractional Knapsack, Interval Merging

#### 10. **Divide and Conquer**
- Merge Sort, Quick Sort, Search in Rotated Array
- Majority Element, Binary Search Variants

#### 11. **Dynamic Programming (DP)**
- 1D, 2D DP, Memoization, Tabulation
- LIS, LCS, Knapsack Family, Matrix Chain, DP on Trees
- Bitmask DP, DP + Binary Search

#### 12. **Graphs**
- Representations (Adj List, Matrix)
- DFS/BFS, Topo Sort, Cycle Detection
- Dijkstra, Bellman-Ford, Floyd-Warshall
- Union-Find (DSU), MST (Kruskal/Prim)

#### 13. **Sliding Window & Two Pointers (in-depth)**
- Substring problems, Optimal Subarrays
- Fixed vs Variable Window
- Merging Two Sorted Arrays, Container With Most Water

#### 14. **Bit Manipulation**
- Basics (AND, OR, XOR), Set/Unset Bit
- Power of Two, Subsets using Bits, XOR Problems
- Bitmask DP intro

#### 15. **Mathematics & Number Theory**
- GCD, LCM, Sieve of Eratosthenes, Modular Arithmetic
- Fast Exponentiation, Combinatorics

---


Bilkul. Here's the roadmap again, but this time with **recommended durations** next to each topic. These durations assume **consistent focused effort (~2–3 hours/day)**. The total is roughly **10–12 weeks** for mastery-level prep. You can speed up or stretch it based on your pace.

---

### 🚀 DSA Roadmap with Timelines

| # | Topic | Duration |
|--|-------|----------|
| 1 | **Arrays & Strings** | 6–7 days |
| 2 | **Hashing / HashMaps / Sets** | 4–5 days |
| 3 | **Recursion & Backtracking** | 6–7 days |
| 4 | **Linked List** | 4–5 days |
| 5 | **Stacks & Queues** | 4–5 days |
| 6 | **Trees (Binary Trees + BST)** | 6–7 days |
| 7 | **Heaps / Priority Queue** | 3–4 days |
| 8 | **Tries** | 3–4 days |
| 9 | **Greedy Algorithms** | 4–5 days |
| 10 | **Divide and Conquer** | 3–4 days |
| 11 | **Dynamic Programming (DP)** | 10–12 days |
| 12 | **Graphs (BFS, DFS, MST, etc.)** | 10–12 days |
| 13 | **Sliding Window & Two Pointers (in-depth)** | 3–4 days |
| 14 | **Bit Manipulation** | 3–4 days |
| 15 | **Mathematics & Number Theory** | 3–4 days |

---

### ⏳ Total Estimated Time: ~70–80 days (≈ 10–12 weeks)

This includes buffer time for:
- Practice problems (LeetCode/Codeforces)
- Revision & mock tests
- Tough concepts you may need to revisit

---

Sahi pakde hain. **Arrays** and **Strings** deserve their own spotlight, even if they sometimes overlap. I’ve split the roadmap into two **independent tracks** now:

---

## 🔷 Arrays – Topic-wise Question Set

### 🟢 **Beginner**

1. Find the Largest Element  
2. Reverse the Array  
3. Check if Array is Sorted  
4. Remove Duplicates from Sorted Array  
5. Left Rotate Array by One  
6. Move All Zeros to End  
7. Frequency of Elements (using HashMap)  
8. Linear & Binary Search  
9. Rotate Array (using temp array / reversal algorithm)

---

### 🟡 **Intermediate**

10. Kadane’s Algorithm (Max Subarray Sum)  
11. Two Sum  
12. Sort 0s, 1s, 2s (Dutch National Flag)  
13. Merge Two Sorted Arrays  
14. Intersection of Two Arrays  
15. Longest Subarray with Given Sum (Positive + 0)  
16. Subarray with Given XOR  
17. Rearrange Array Elements (positive/negative alternately)  
18. Leaders in an Array  

---

### 🔴 **Advanced**

19. Trapping Rain Water  
20. Maximum Product Subarray  
21. Median of Two Sorted Arrays  
22. Find Duplicate Number (Cycle detection)  
23. Maximum Sum Circular Subarray  
24. Count Inversions (Merge Sort based)  
25. Sliding Window Maximum (Deque based)  
26. Minimum Swaps to Bring Elements < K Together

---

## 🔶 Strings – Topic-wise Question Set

### 🟢 **Beginner**

1. Check Palindrome  
2. Reverse a String  
3. Count Vowels & Consonants  
4. Check Anagrams  
5. Remove Duplicates from String  
6. Change Case (lower → upper etc.)  
7. Substring Generation (Brute force understanding)  
8. String Compression (like Leetcode 443)

---

### 🟡 **Intermediate**

9. Longest Substring Without Repeating Characters  
10. Longest Common Prefix  
11. Group Anagrams  
12. Longest Palindromic Substring  
13. Implement strstr() / indexOf()  
14. Count and Say  
15. Check if Rotation of Another String  
16. Ransom Note (HashMap-based)  

---

### 🔴 **Advanced**

17. Rabin Karp / KMP Algorithm (Pattern Matching)  
18. Minimum Window Substring  
19. Z Algorithm  
20. Multiply Two Large Strings  
21. Longest Repeating Subsequence  
22. Wildcard Pattern Matching  
23. Edit Distance (DP)  
24. Remove Invalid Parentheses  

---

---

## 🔷 **Hashing / HashMaps / HashSets**

### 🧠 **Core Concepts You Should Know First**
- Hash Functions & Collisions (theory)
- HashMap vs HashSet
- Time Complexity for operations
- How to use them in frequency counting, lookups, etc.

---

## 🔥 Hashing – Tiered Problem Set

### 🟢 **Beginner**

1. **Count Frequency of Elements in Array**
2. **Check if Two Arrays are Equal (unordered)**
3. **Check if a String is Anagram of Another**
4. **First Non-Repeating Character in a String**
5. **Find Element with Odd Occurrences**
6. **Find Duplicates in Array**
7. **Union and Intersection of Two Arrays**
8. **Find the Missing Number (1 to n)**

---

### 🟡 **Intermediate**

9. **Longest Consecutive Sequence**
10. **Subarray with 0 Sum**
11. **Count Subarrays with Given Sum**
12. **4-Sum / 3-Sum Problem**
13. **Group Anagrams**
14. **Isomorphic Strings**
15. **Top K Frequent Elements**
16. **Check if Array can be Divided in Pairs with Equal Sum**
17. **Longest Subarray with Equal 0s and 1s**

---

### 🔴 **Advanced**

18. **Count Distinct Elements in Every Window (Size K)**
19. **Minimum Window Substring (HashMap based)**
20. **Smallest Subarray with All Occurrences of Most Frequent Element**
21. **Check for Subarray with Equal Number of 1s and 0s**
22. **Maximum Points on a Line (custom hash with precision)**
23. **Implement LRU Cache (HashMap + DLL)**

---
---

## 🔷 Topic 3: **Recursion & Backtracking**  
🕒 **Recommended Time**: ~6–7 days

---

### 📅 Day 1 – **Recursion Basics**

1. Print Numbers (1 to N and N to 1)  
2. Factorial Using Recursion  
3. Fibonacci Using Recursion  
4. Sum of Digits / Product of Digits  
5. Check Palindrome Using Recursion  
6. Power of a Number (Recursive + Fast Exponentiation)  

> 🎯 Goal: Build recursion flowchart intuition (Call Stack Mentality)

---

### 📅 Day 2 – **Array/String-Based Recursion**

1. Check if Array is Sorted (Recursive)  
2. Linear Search Recursively  
3. Binary Search Recursively  
4. Reverse a String Recursively  
5. Replace All Occurrences of a Character  
6. Print All Subsequences of a String  

---

### 📅 Day 3 – **Backtracking Foundations**

1. Subset Generation (Power Set)  
2. String Permutations  
3. Permutations of Array Elements  
4. Letter Case Permutation  
5. Generate Balanced Parentheses  
6. Palindrome Partitioning

> 🎯 Goal: Understand *Choose → Explore → Unchoose* pattern

---

### 📅 Day 4 – **Classic Backtracking Problems**

1. N-Queens Problem  
2. Rat in a Maze  
3. Sudoku Solver  
4. Word Search in Grid  
5. M-Coloring Problem  
6. Knights Tour Problem (optional deep dive)

---

### 📅 Day 5 – **Combination-Type Problems**

1. Combination Sum I / II  
2. Subsets with Duplicates  
3. K Sum Paths (in arrays/trees)  
4. Restore IP Addresses  
5. Expression Add Operators (Leetcode hard but intuitive)

---

### 📅 Day 6 – **Tightening Skills + Optimization**

- Understand Pruning Techniques  
- Bitmasking in Backtracking (light intro)  
- Analyze and rewrite earlier solutions iteratively

---

### 📅 Day 7 – **Mock Practice Set / Revision**

- Mix of 5–6 problems across difficulty  
- Try solving N-Queens or Sudoku from scratch  
- Revisit recursion tree diagrams for tough ones

---

### 🔚 End Goal: Be able to:
- Write & debug recursive solutions confidently  
- Visualize recursion tree  
- Backtrack with constraint handling  
- Optimize using memoization where applicable  

---z

---

## 🔷 Topic 4: **Linked List**  
🕒 **Recommended Time**: ~4–5 days

---

### 📅 Day 1 – **Singly Linked List Basics**

1. Implement Singly Linked List (insert, delete, traverse)  
2. Find Length of Linked List  
3. Search Element in Linked List  
4. Find the Middle of the Linked List (slow-fast pointer)  
5. Detect Loop (Floyd’s Cycle Detection)  
6. Remove Loop from Linked List  

> 🎯 Goal: Be comfortable with pointer movement and basic utilities

---

### 📅 Day 2 – **Classic Operations**

1. Reverse a Linked List (Iterative & Recursive)  
2. Merge Two Sorted Linked Lists  
3. Delete Nth Node from End (two-pointer technique)  
4. Check if Linked List is Palindrome  
5. Intersection Point of Two Linked Lists  
6. Remove Duplicates from Sorted List  

---

### 📅 Day 3 – **Advanced Patterns**

1. Add Two Numbers Represented by LL  
2. Copy List with Random Pointer  
3. Rotate Linked List  
4. Flatten a Multilevel Linked List  
5. Merge K Sorted Linked Lists (using Heap)  
6. LRU Cache (Linked List + HashMap) – revisit from Hashing  

> 🎯 Goal: Handle complex node references and simulate memory structures

---

### 📅 Day 4 – **Doubly & Circular LL + Revision**

1. Implement Doubly Linked List  
2. Reverse Doubly Linked List  
3. Circular Linked List – Detect Loop  
4. Split a Circular Linked List  
5. Practice 2–3 previously unsolved problems  
6. Write 2–3 full implementations from scratch

---

### 📅 Day 5 – **Mock Problems / Assessment Day**

- 5–6 mixed problems across difficulty  
- Test under time constraint  
- Solve at least 1 **Merge K Sorted Lists** or **Copy List with Random Pointer** from memory

---

---

## 🔷 Topic 5: **Stacks & Queues**  
🕒 **Recommended Time**: ~4–5 days

---

### 📅 Day 1 – **Basics + Stack Implementation**

1. Implement Stack using Array  
2. Implement Stack using Linked List  
3. Infix to Postfix Conversion  
4. Evaluate Postfix Expression  
5. Valid Parentheses  
6. Min Stack (O(1) getMin)  
7. Next Greater Element (Brute + Stack)

> 🎯 Goal: Understand LIFO behavior and expression handling

---

### 📅 Day 2 – **Queue Variants + Circular Queue**

1. Implement Queue using Array  
2. Implement Queue using Stack  
3. Circular Queue Implementation  
4. Deque (Double-ended Queue)  
5. First Non-Repeating Character in Stream  
6. Implement Stack using Queues

> 🎯 Goal: Build mental models for FIFO and two-stack manipulations

---

### 📅 Day 3 – **Monotonic Stack / Pattern Problems**

1. Largest Rectangle in Histogram  
2. Trapping Rain Water (using Stack)  
3. Daily Temperatures  
4. Remove K Digits  
5. Asteroid Collision  
6. Score of Parentheses

> 🎯 Goal: Use stacks for **monotonic patterns** and optimal solutions

---

### 📅 Day 4 – **Sliding Window + Deque Based Problems**

1. Sliding Window Maximum (Deque)  
2. First Negative Integer in Every Window of Size K  
3. Sum of Minimums of All Subarrays  
4. Stock Span Problem  
5. Maximum of All Subarrays of Size K  
6. Circular Tour / Petrol Pump Problem

---

### 📅 Day 5 – **Mock + Mixed Problems**

- Mix of 5–6 timed problems (Stacks, Queues, Deques)  
- Revisit one implementation-heavy problem (e.g. Min Stack, LRU)  
- Revise monotonic stack pattern & sliding window template

---

---

## 🔷 Topic 6: **Trees (Binary Trees + BST)**  
🕒 **Recommended Time**: ~6–7 days

---

### 📅 Day 1 – **Binary Tree Basics + Traversals**

1. Build Binary Tree from Array / Input  
2. Inorder, Preorder, Postorder Traversal (Recursive)  
3. Level Order Traversal (BFS)  
4. Height / Depth of a Binary Tree  
5. Count Nodes, Leaf Nodes, Diameter of Tree  
6. Mirror of Binary Tree

> 🎯 Goal: Master basic structure & traversals (recursive + iterative)

---

### 📅 Day 2 – **Binary Search Tree (BST) Basics**

1. Insert, Search, Delete in BST  
2. Validate if Tree is BST  
3. Find Floor & Ceil in BST  
4. Kth Smallest/Largest Element in BST  
5. Lowest Common Ancestor (LCA) in BST  
6. Convert Sorted Array to BST

> 🎯 Goal: Practice recursive BST logic + in-order property

---

### 📅 Day 3 – **Advanced Traversals & Techniques**

1. Iterative Inorder, Preorder, Postorder  
2. Morris Traversal (Inorder without stack/recursion)  
3. Zigzag / Spiral Order Traversal  
4. Vertical Order Traversal  
5. Boundary Traversal  
6. Top View / Bottom View / Left View / Right View

> 🎯 Goal: Solve BFS-based structured view problems

---

### 📅 Day 4 – **Binary Tree: Important Patterns**

1. Maximum Path Sum  
2. Check if Tree is Balanced  
3. Symmetric Tree  
4. Root to Leaf Path Sum  
5. Print All Root to Leaf Paths  
6. Path Sum Equals Target (All Paths)

---

### 📅 Day 5 – **Tree Construction Problems**

1. Build Tree from Inorder + Preorder  
2. Build Tree from Inorder + Postorder  
3. Serialize and Deserialize Binary Tree  
4. Flatten Binary Tree to Linked List  
5. Binary Tree to DLL  
6. Tree to Sum Tree

> 🎯 Goal: Master reconstructive recursion

---

### 📅 Day 6 – **Binary Tree LCA + Ancestors + Diameter**

1. LCA in Binary Tree  
2. Distance Between Two Nodes  
3. Nodes at K Distance from Target  
4. Diameter of Binary Tree (optimized)  
5. Burning Tree Problem  
6. Time to Burn Tree from Leaf Node (Fire Spread)

---

### 📅 Day 7 – **Mock + Revision Day**

- Attempt 6–8 mixed-level problems  
- Rebuild tree from traversals  
- One full pass of LCA, diameter, views

---
---

## 🔷 Topic 7: **Heaps / Priority Queue**  
🕒 **Recommended Time**: ~3–4 days

---

### 📅 Day 1 – **Heap Basics + Implementation**

1. Implement Min Heap / Max Heap from scratch  
2. Insert, Delete, Heapify  
3. Heap Sort  
4. Convert Array into Heap (buildHeap)  
5. Kth Largest / Smallest Element in Array  
6. Is Binary Tree a Heap?

> 🎯 Goal: Understand the heap property, heapify logic, and STL/Java/Python priority queue usage

---

### 📅 Day 2 – **Top K / Frequency-Based Problems**

1. Top K Frequent Elements  
2. K Closest Numbers / Points to Origin  
3. Sort Characters by Frequency  
4. Rearrange String with No Adjacent Same  
5. Frequency Sort  
6. Sort a Nearly Sorted (K-sorted) Array

> 🎯 Goal: Apply min/max heaps for optimized sorting and filtering

---

### 📅 Day 3 – **Advanced Heap Use Cases**

1. Median in a Stream (Two Heaps)  
2. Merge K Sorted Lists (again)  
3. Find Kth Largest in a Stream  
4. Sliding Window Median  
5. Task Scheduler (Greedy + Heap)  
6. Huffman Encoding Tree (Theory + Implementation)

> 🎯 Goal: Handle streaming data, real-time ranking, and greedy scheduling

---

### 📅 Day 4 – **Mock + Mix Day**

- Practice ~5–6 problems involving:  
  - Top-K  
  - Stream-based inputs  
  - Heapify tricks  
- Re-implement Heap manually once to solidify internals

---

---

## 🔷 Topic 8: **Tries (Prefix Trees)**  
🕒 **Recommended Time**: ~3–4 days

---

### 📅 Day 1 – **Trie Basics + Implementation**

1. Implement Trie (Insert, Search, StartsWith)  
2. Search Word in Trie  
3. Delete Word from Trie  
4. Count Words with Given Prefix  
5. Longest Prefix Matching (like T9 prediction)  
6. Auto-Complete Feature using Trie

> 🎯 Goal: Understand node-based prefix tree structure & operations

---

### 📅 Day 2 – **Pattern Matching + Word Problems**

1. Word Dictionary with Wildcard Search (`.`, like LeetCode 211)  
2. Word Break I (DP + Trie variant)  
3. Word Break II (Backtracking + Trie optional)  
4. Word Search II (Backtracking + Trie)  
5. Replace Words (Dictionary Based Sentence Rewriting)  
6. Maximum XOR of Two Numbers in an Array

> 🎯 Goal: Combine trie with recursion, backtracking & DP

---

### 📅 Day 3 – **Advanced Applications**

1. Most Frequent Word in Stream  
2. Unique Prefix for Every Word  
3. Number of Distinct Substrings in a String  
4. Suffix Trie / Suffix Automaton (optional advanced)  
5. Palindrome Pairs (Hard but killer problem)  
6. Trie + Bitmasking Combo Problems

> 🎯 Goal: Use Trie with other patterns (bitmasking, DFS, streams)

---

### 📅 Day 4 – **Mock & Revision**

- Rebuild Trie from scratch  
- Solve 5–6 problems across all types  
- Mix of autocomplete + word break + pattern matching

---

---

## 🔷 Topic 9: **Greedy Algorithms**  
🕒 **Recommended Time**: ~4–5 days

---

### 📅 Day 1 – **Greedy Basics + Sorting Based Greedy**

1. Activity Selection Problem  
2. Fractional Knapsack  
3. Minimum Number of Platforms (Train Schedule)  
4. Job Sequencing Problem  
5. N Meetings in One Room  
6. Largest Number from Array (custom sort)

> 🎯 Goal: Learn greedy decision-making via sorting & intervals

---

### 📅 Day 2 – **Greedy with Intervals & Events**

1. Merge Overlapping Intervals  
2. Insert Interval  
3. Minimum Arrows to Burst Balloons  
4. Gas Station (Circular Tour)  
5. Jump Game I & II  
6. Lemonade Change

> 🎯 Goal: Solve coverage-based problems using greedy picks

---

### 📅 Day 3 – **Greedy in Strings & Arrays**

1. Remove K Digits  
2. Reorganize String  
3. Minimum Number of Coins  
4. Minimum Swaps for Bracket Balancing  
5. Candy Distribution Problem  
6. Boats to Save People

> 🎯 Goal: Practice character and structure reordering

---

### 📅 Day 4 – **Greedy + PQ / Advanced Use-Cases**

1. Huffman Encoding Tree (again, optional revisit)  
2. Greedy Florist  
3. Scheduling Meetings in Rooms (Min Heap-based)  
4. Greedy Coloring of Graph (if touching graphs)  
5. Task Scheduler (also solved using Heap in past)  
6. Optimal Merge Pattern

> 🎯 Goal: Combine Greedy with other data structures

---

### 📅 Day 5 – **Mock Day**

- Try 5–7 problems in a timed session  
- Mix of interval, string, and coin-based problems  
- Re-validate if you can distinguish *where greedy works and where it doesn’t*

---
---

## 🔷 Topic 10: **Divide and Conquer**  
🕒 **Recommended Time**: ~3–4 days

---

### 📅 Day 1 – **Foundations + Classic Problems**

1. Binary Search (Recursive + Iterative)  
2. Merge Sort (Divide & Conquer core)  
3. Quick Sort (with partition logic)  
4. Count Inversions in Array  
5. Search in Rotated Sorted Array  
6. Find Peak Element

> 🎯 Goal: Get solid with base divide-and-conquer skeleton + recursion flow

---

### 📅 Day 2 – **Matrix & Modified Binary Search**

1. Median of Two Sorted Arrays  
2. Kth Element in Two Sorted Arrays  
3. Search a 2D Matrix I & II  
4. Find Row with Maximum Number of 1s  
5. Matrix Exponentiation  
6. Power Function (Fast Exponentiation)

> 🎯 Goal: Understand how to break matrix/grid recursively

---

### 📅 Day 3 – **Harder D&C Problems**

1. Maximum Subarray (Kadane vs Divide & Conquer)  
2. Closest Pair of Points  
3. Majority Element using D&C  
4. Skyline Problem (LeetCode Hard)  
5. Merge K Sorted Lists (Heap or D&C based)

> 🎯 Goal: Solve tough ones using efficient subproblem merging

---

### 📅 Day 4 – **Mock + Recap**

- 5–6 handpicked D&C problems (search, sort, subarray)  
- Compare recursion vs iteration approach for 1–2 problems  
- Build a recursive tree for at least one problem to visualize splits

---

---

## 🔷 Topic 11: **Dynamic Programming (DP)**  
🕒 **Recommended Time**: ~10–12 days

---

### 📅 Day 1 – **Intro to DP + Memoization vs Tabulation**

1. Fibonacci (Recursive → Memo → Tabulation)  
2. Climbing Stairs  
3. Min Cost Climbing Stairs  
4. House Robber  
5. Decode Ways (Leetcode 91)  
6. Count Ways to Reach Nth Step

> 🎯 Goal: Build muscle memory for **overlapping subproblems** + optimal substructure

---

### 📅 Day 2 – **1D DP Continued**

1. Jump Game  
2. Jump Game II  
3. Maximum Sum of Non-Adjacent Elements  
4. Partition Equal Subset Sum  
5. Can Sum / How Sum / Best Sum (Recursion to DP)

---

### 📅 Day 3 – **2D DP Basics (Grids)**

1. Unique Paths I & II  
2. Minimum Path Sum  
3. Coin Change I & II  
4. 0/1 Knapsack  
5. Subset Sum  
6. Target Sum (Transform to Subset Sum)

---

### 📅 Day 4 – **Strings DP I**

1. Longest Common Subsequence (LCS)  
2. Longest Palindromic Substring  
3. Longest Palindromic Subsequence  
4. Edit Distance  
5. Minimum Insertions to Make Palindrome  
6. Shortest Common Supersequence

---

### 📅 Day 5 – **Strings DP II**

1. Wildcard Matching  
2. Regular Expression Matching  
3. Distinct Subsequences  
4. Count Palindromic Substrings  
5. Delete Operation for Two Strings  
6. Interleaving Strings

---

### 📅 Day 6 – **DP on LIS / Subsequence Pattern**

1. Longest Increasing Subsequence  
2. Number of LIS  
3. Longest Bitonic Subsequence  
4. Maximum Sum Increasing Subsequence  
5. Russian Doll Envelopes  
6. Building Bridges

---

### 📅 Day 7 – **DP on Partitioning / Cuts**

1. Palindrome Partitioning II (Min cuts)  
2. Burst Balloons  
3. Matrix Chain Multiplication  
4. Optimal BST  
5. Rod Cutting Problem  
6. Egg Dropping Puzzle

---

### 📅 Day 8 – **DP on Stocks**

1. Best Time to Buy and Sell Stock I–V  
2. Buy and Sell with Cooldown  
3. Buy and Sell with Transaction Fee  
4. At Most K Transactions  
5. Infinite Transactions  
6. Single Transaction + Cooldown Combined

---

### 📅 Day 9 – **Advanced Patterns**

1. DP on Trees (e.g. Diameter, Robbery in Binary Tree)  
2. DP on Grids with Obstacles  
3. DP + Bitmasking (e.g. Traveling Salesman Problem)  
4. Minimum Cost to Merge Stones  
5. Paint House I, II, III  
6. Cherry Pickup I / II

---

### 📅 Day 10 – **Mock + High-Impact Practice**

- Solve 6–8 mixed DP problems  
- Solve 1 or 2 from scratch (without template)  
- Review common transitions, space optimizations

---

---

## 🔷 Topic 12: **Graphs**  
🕒 **Recommended Time**: ~8–10 days

---

### 📅 Day 1 – **Graph Representations + Traversals**

1. Adjacency List / Matrix / Edge List  
2. BFS (Level-wise Traversal)  
3. DFS (Recursive + Iterative)  
4. Detect Cycle in Undirected Graph  
5. Detect Cycle in Directed Graph  
6. Connected Components (DFS/BFS-based)

> 🎯 Goal: Be clear on graph modeling and basic traversals

---

### 📅 Day 2 – **Topological Sorting + Variants**

1. Topological Sort (DFS-based)  
2. Topo Sort using Kahn’s Algorithm (BFS)  
3. Detect Cycle in Directed Graph using Kahn’s Algo  
4. Course Schedule I & II  
5. Alien Dictionary  
6. Sort Items by Groups Respecting Dependencies

---

### 📅 Day 3 – **Shortest Path – Dijkstra & BFS Based**

1. Dijkstra’s Algorithm (PQ-based)  
2. 01 Matrix (Multi-source BFS)  
3. Shortest Path in Binary Matrix  
4. Path with Minimum Effort  
5. Cheapest Flights Within K Stops  
6. Network Delay Time

> 🎯 Goal: Understand cost-based BFS and weighted graph traversal

---

### 📅 Day 4 – **Shortest Path – Bellman Ford & Floyd-Warshall**

1. Bellman Ford Algorithm  
2. Detect Negative Cycle (Bellman Ford)  
3. Floyd-Warshall – All Pairs Shortest Path  
4. Minimum Time to Complete All Tasks  
5. Graph with Time-Dependent Edges  
6. Reachable Nodes in Subdivided Graph

---

### 📅 Day 5 – **Minimum Spanning Tree (MST)**

1. Prim’s Algorithm  
2. Kruskal’s Algorithm (Union-Find)  
3. Connecting Cities with Minimum Cost  
4. Network Connection / Disconnection Problems  
5. Redundant Connection  
6. Optimize Water Distribution in a Village

---

### 📅 Day 6 – **Union-Find (Disjoint Set Union – DSU)**

1. Union by Rank + Path Compression  
2. Number of Provinces / Islands  
3. Accounts Merge  
4. Satisfiability of Equality Equations  
5. Detect Cycle using DSU  
6. Kruskal’s Algorithm (Revisit with DSU)

---

### 📅 Day 7 – **Graph on Grid / Maze Problems**

1. Number of Islands  
2. Surrounded Regions  
3. Word Search  
4. Rotting Oranges  
5. Walls and Gates  
6. Shortest Path in Maze with Obstacles

---

### 📅 Day 8 – **Advanced Graphs & Practice**

1. Articulation Points and Bridges  
2. Tarjan’s Algorithm for SCC  
3. Kosaraju's Algorithm  
4. Dijkstra with Heuristics (A*)  
5. Minimum Cost to Make Graph Connected  
6. Eulerian Path / Circuit

---

### 📅 Day 9 – **Mock + Revision Day**

- Solve 6–8 problems across DSU, MST, Traversals  
- Redo 2 major algorithms from scratch (Dijkstra + Kruskal/Prim)  
- Revise template approaches for BFS, DFS, Union-Find

---

**Curated DSA Problem Set** — topic-wise, with 90–95% of the patterns that appear in interviews and contests.

Each topic is split into **3 levels**:  
- **P1** – Foundation / Easy  
- **P2** – Standard Interview Problems  
- **P3** – Edge Cases / Advanced

---

## 🔷 **1. Arrays**

### ✅ P1:
- Two Sum – *LeetCode 1*  
- Move Zeroes – *LeetCode 283*  
- Best Time to Buy and Sell Stock – *LeetCode 121*  
- Kadane's Algorithm – *LC 53*  
- Left Rotate Array by K – *GFG*  

### ✅ P2:
- Merge Intervals – *LC 56*  
- Majority Element – *LC 169*  
- Subarray Sum Equals K – *LC 560*  
- Next Permutation – *LC 31*  
- Missing Number – *LC 268*  

### ✅ P3:
- Maximum Product Subarray – *LC 152*  
- Count Inversions – *GFG / Merge Sort based*  
- Maximum Subarray Sum in Circular Array – *LC 918*  
- Median of Two Sorted Arrays – *LC 4*

---

## 🔷 **2. Strings**

### ✅ P1:
- Valid Palindrome – *LC 125*  
- Reverse Words in a String – *LC 151*  
- Isomorphic Strings – *LC 205*  
- Implement strStr() – *LC 28*

### ✅ P2:
- Longest Common Prefix – *LC 14*  
- Group Anagrams – *LC 49*  
- Longest Substring Without Repeating Characters – *LC 3*  
- Check for Anagrams – *LC 242*

### ✅ P3:
- Minimum Window Substring – *LC 76*  
- Longest Palindromic Substring – *LC 5*  
- Regular Expression Matching – *LC 10*  
- Wildcard Matching – *LC 44*

---

## 🔷 **3. Linked List**

### ✅ P1:
- Reverse a Linked List – *LC 206*  
- Detect Cycle – *LC 141*  
- Find Middle of Linked List – *LC 876*  
- Merge Two Sorted Lists – *LC 21*

### ✅ P2:
- Remove N-th Node from End – *LC 19*  
- Add Two Numbers – *LC 2*  
- Intersection of Two Linked Lists – *LC 160*  
- Copy List with Random Pointer – *LC 138*

### ✅ P3:
- LRU Cache – *LC 146*  
- Merge K Sorted Lists – *LC 23*  
- Reverse Nodes in K Group – *LC 25*

---

## 🔷 **4. Stack & Queue**

### ✅ P1:
- Valid Parentheses – *LC 20*  
- Min Stack – *LC 155*  
- Implement Queue using Stacks – *LC 232*  
- Next Greater Element I – *LC 496*

### ✅ P2:
- Daily Temperatures – *LC 739*  
- Asteroid Collision – *LC 735*  
- Sliding Window Maximum – *LC 239*  
- Evaluate Reverse Polish Notation – *LC 150*

### ✅ P3:
- Largest Rectangle in Histogram – *LC 84*  
- Trapping Rain Water – *LC 42*

---

## 🔷 **5. Trees & BST**

### ✅ P1:
- Inorder, Preorder, Postorder Traversals – *LC 94, 144, 145*  
- Level Order Traversal – *LC 102*  
- Max Depth of Binary Tree – *LC 104*  
- Symmetric Tree – *LC 101*

### ✅ P2:
- Diameter of Binary Tree – *LC 543*  
- Lowest Common Ancestor – *LC 236*  
- Serialize and Deserialize Binary Tree – *LC 297*  
- Validate BST – *LC 98*

### ✅ P3:
- Kth Smallest in BST – *LC 230*  
- Recover Binary Search Tree – *LC 99*  
- Path Sum III – *LC 437*  
- All Paths from Root to Leaf – *LC 257*

---

## 🔷 **6. Heaps / Priority Queue**

### ✅ P1:
- Kth Largest Element in Array – *LC 215*  
- Top K Frequent Elements – *LC 347*  
- Sort Characters by Frequency – *LC 451*  
- Merge K Sorted Lists – *LC 23*

### ✅ P2:
- Find Median from Data Stream – *LC 295*  
- Task Scheduler – *LC 621*  
- Sliding Window Median – *LC 480*  
- Reorganize String – *LC 767*

---

## 🔷 **7. Tries**

### ✅ P1:
- Implement Trie – *LC 208*  
- Word Search II – *LC 212*  
- Replace Words – *LC 648*

### ✅ P2:
- Design Add and Search Words – *LC 211*  
- Longest Word in Dictionary – *LC 720*  
- Palindrome Pairs – *LC 336*

---

## 🔷 **8. Greedy**

### ✅ P1:
- Activity Selection / N Meetings – *GFG*  
- Gas Station – *LC 134*  
- Jump Game – *LC 55*  
- Lemonade Change – *LC 860*

### ✅ P2:
- Merge Intervals – *LC 56*  
- Minimum Number of Arrows – *LC 452*  
- Reorganize String – *LC 767*  
- Partition Labels – *LC 763*

---

## 🔷 **9. Divide & Conquer**

- Merge Sort  
- Quick Sort  
- Search in Rotated Sorted Array – *LC 33*  
- Count Inversions – *GFG*  
- Median of Two Sorted Arrays – *LC 4*

---

## 🔷 **10. Dynamic Programming**

### ✅ P1:
- Climbing Stairs – *LC 70*  
- House Robber – *LC 198*  
- Unique Paths – *LC 62*  
- Coin Change – *LC 322*

### ✅ P2:
- Longest Palindromic Subsequence – *LC 516*  
- Edit Distance – *LC 72*  
- Longest Common Subsequence – *LC 1143*  
- Partition Equal Subset Sum – *LC 416*

### ✅ P3:
- Burst Balloons – *LC 312*  
- Palindrome Partitioning II – *LC 132*  
- Cherry Pickup – *LC 741*  
- Regular Expression Matching – *LC 10*

---

## 🔷 **11. Graphs**

### ✅ P1:
- Number of Islands – *LC 200*  
- Clone Graph – *LC 133*  
- Detect Cycle in Graph – *GFG*  
- BFS / DFS Traversals – *Standard*

### ✅ P2:
- Topological Sort – *Kahn’s Algo, GFG*  
- Course Schedule – *LC 207/210*  
- Dijkstra’s Algorithm – *LC 743*  
- Bellman-Ford – *GFG*

### ✅ P3:
- MST (Kruskal / Prim) – *LC 1135, GFG*  
- Union Find – *LC 684, 547*  
- Tarjan's Algo / Bridges – *Advanced*

---

